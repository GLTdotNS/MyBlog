"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeProblems = getTypeProblems;
exports.default = groupProblems;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _createValidationResult = require("./validation/createValidationResult");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTypeWithMembersProblemsAccessor(memberPropertyName) {
  let getMembers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : type => (0, _get2.default)(type, memberPropertyName);
  return function getProblems(type, parentPath) {
    const currentPath = [...parentPath, {
      kind: 'type',
      type: type.type,
      name: type.name
    }];
    const members = getMembers(type) || [];
    const memberProblems = Array.isArray(members) ? members.map(memberType => {
      const memberPath = [...currentPath, {
        kind: 'property',
        name: memberPropertyName
      }];
      return getTypeProblems(memberType, memberPath);
    }) : [{
      path: currentPath,
      problems: [(0, _createValidationResult.error)(`Member declaration (${memberPropertyName}) is not an array`)]
    }];
    return [{
      path: currentPath,
      problems: type._problems || []
    }, ...(0, _flatten2.default)(memberProblems)];
  };
}

const arrify = val => Array.isArray(val) ? val : typeof val === 'undefined' && [] || [val];

const getObjectProblems = createTypeWithMembersProblemsAccessor('fields');
const getArrayProblems = createTypeWithMembersProblemsAccessor('of');
const getReferenceProblems = createTypeWithMembersProblemsAccessor('to', type => arrify(type.to));
const getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor('marks.annotations');
const getBlockMemberProblems = createTypeWithMembersProblemsAccessor('of');

const getBlockProblems = function getBlockProblems() {
  return [...getBlockAnnotationProblems(...arguments), ...getBlockMemberProblems(...arguments)];
};

function getDefaultProblems(type) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return [{
    path: [...path, {
      kind: 'type',
      type: type.type,
      name: type.name
    }],
    problems: type._problems || []
  }];
}

function getTypeProblems(type) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  switch (type.type) {
    case 'object':
      {
        return getObjectProblems(type, path);
      }

    case 'document':
      {
        return getObjectProblems(type, path);
      }

    case 'array':
      {
        return getArrayProblems(type, path);
      }

    case 'reference':
      {
        return getReferenceProblems(type, path);
      }

    case 'block':
      {
        return getBlockProblems(type, path);
      }

    default:
      {
        return getDefaultProblems(type, path);
      }
  }
}

function groupProblems(types) {
  return (0, _flatten2.default)(types.map(type => getTypeProblems(type))).filter(type => type.problems.length > 0);
}